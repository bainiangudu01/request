# # 简单版选择排序
# def select_sort_simple(l):
#     l_new = []  # 需要一个新列表，将拿出的最小的数放里边
#     for i in range(len(l)):  # 每次遍历拿出一个数，需要遍历n遍
#         min_val = min(l)  # 每次遍历需要找出这个最小数，
#         l_new.append(min_val)  # 将找出的最小数放到新列表里
#         l.remove(min_val)  # 然后将这个最小数从原列表里删除
#     return l_new  # 最后返回新的列表
#
#
# l = [3, 2, 4, 1, 5, 6, 8, 7, 9]
# print(select_sort_simple(l))


# 这个算法不推荐写，有几个致命缺点
# 1、生成了两个列表，多占了一份内存，如果原来列表1个g数据，现在会占用2个g（冒泡排序是原地排序，在原来列表位置上通过交换来排序，现在这个不是）
# 2、复杂度为O(n^2)，因为这里的min操作和remove操作（删除一个，后边的元素需要挪到前边）复杂度都是O(n)

# 优化后的选择排序（建议写这个）
# 不创建一个新的列表，需要将选择出来的最小数放到列表最前面（和最前面的数进行交换)，变成有序区，接下来找无序区最小数，跟无序区第一个数交换
def select_sort(l):
    for i in range(len(l) - 1):  # 和冒泡排序一样，n-1趟放完之后，剩一个数，一定是最大的，不用管它直接就放在最后，所以需要n-1趟
        min_loc = i  # 假定无序区第一个位置的数是最小数，然后和后边比，只要后边比它小，就可以交换
        for j in range(i + 1, len(l)):  # 从i+1开始，将i+1位置的数和i进行对比
            if l[j] < l[min_loc]:  # 如果我们遍历的这个数比min_log位置上的数小，就将最小数的位置记为j
                min_loc = j
        l[i], l[min_loc] = l[min_loc], l[i]  # 循环结束，找到这个最小值后，将i位置的值和min_log位置（此时为j位置）的值进行交换
    return l


l = [3, 2, 4, 1, 5, 6, 8, 7, 9]
print(select_sort(l))
